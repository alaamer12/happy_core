import asyncio
import time
import weakref

# Generated by Qodo Gen

from true.asyn import Asyn, TaskPriority, TaskState

import pytest

class TestAsyn:

    # Task creation and execution with proper state transitions (PENDING -> RUNNING -> COMPLETED)
    @pytest.mark.asyncio
    async def test_task_state_transitions(self):
        task = Asyn(name="test_task")
        assert task.state == TaskState.PENDING
    
        async def dummy_work():
            await asyncio.sleep(0.1)
            return "done"
        
        result = await task.run(dummy_work())
        assert result == "done"
        assert task.state == TaskState.COMPLETED

    # Parent-child task relationship management with automatic cleanup
    @pytest.mark.asyncio
    async def test_parent_child_cleanup(self):
        parent = Asyn(name="parent")
        child = Asyn(name="child", parent=parent)
    
        assert child in parent.children
        await parent.cancel()
        assert child not in parent.children
        assert child.state == TaskState.CANCELLED

    # Task monitoring and zombie task detection
    @pytest.mark.asyncio
    async def test_zombie_detection(self):
        parent = Asyn(name="parent")
        child = Asyn(name="zombie_child", parent=parent)
        child._info.state = TaskState.COMPLETED
        child._info.end_time = time.time() - Asyn.MAX_ZOMBIE_AGE - 1
    
        await parent._cleanup_zombies()
        assert child not in parent.children

    # Task cancellation with proper cleanup and dependency notification
    @pytest.mark.asyncio
    async def test_cancellation_with_dependencies(self):
        task1 = Asyn("task1")
        task2 = Asyn("task2")
        task2.add_dependency(task1)
    
        await task1.cancel(reason="test")
        assert task1.state == TaskState.CANCELLED
        assert task2.state == TaskState.BLOCKED

    # Task group creation and concurrent task execution
    @pytest.mark.asyncio
    async def test_task_group_execution(self):
        async def work(x):
            await asyncio.sleep(0.1)
            return x * 2
        
        async with Asyn.create_task_group() as group:
            results = []
            for i in range(3):
                task = await group.create_task(work(i))
                results.append(task)
            
        assert len(results) == 3

    # Resource limit monitoring and enforcement
    @pytest.mark.asyncio
    async def test_resource_limits(self):
        task = Asyn("resource_test")
        task.set_resource_limit(runtime=0.1)
    
        async def long_work():
            await asyncio.sleep(0.2)
        
        with pytest.raises(Exception):
            await task.run(long_work())

    # Handling task failures and exceptions with proper state transitions
    @pytest.mark.asyncio
    async def test_task_failure_handling(self):
        task = Asyn("failing_task")
    
        async def failing_work():
            raise ValueError("test error")
        
        with pytest.raises(ValueError):
            await task.run(failing_work())
        
        assert task.state == TaskState.FAILED
        assert isinstance(task.info.exception, ValueError)

    # Cleanup of tasks during garbage collection
    @pytest.mark.asyncio
    async def test_gc_cleanup(self):
        task = Asyn("gc_task")
        weak_ref = weakref.ref(task)
    
        async def work():
            await asyncio.sleep(0.1)
        
        task._info.task = asyncio.create_task(work())
        del task
    
        await asyncio.sleep(0.2)
        assert weak_ref() is None

    # Deadlock detection in task dependencies
    @pytest.mark.asyncio
    async def test_deadlock_detection(self):
        task1 = Asyn("task1")
        task2 = Asyn("task2")
        task1.add_dependency(task2)
        task2.add_dependency(task1)
    
        cycle = task1.info.check_deadlock()
        assert cycle is not None
        assert len(cycle) == 2

    # Task starvation detection and handling
    @pytest.mark.asyncio
    async def test_starvation_detection(self):
        task = Asyn("starved_task")
        task.info.state = TaskState.BLOCKED
        task.info._last_active = time.time() - task.info._starvation_threshold - 1
    
        assert task.info.check_starvation(time.time())

    # Timeout handling for task execution and cancellation
    @pytest.mark.asyncio
    async def test_timeout_handling(self):
        task = Asyn("timeout_task")
    
        async def slow_work():
            await asyncio.sleep(1.0)
        
        with pytest.raises(asyncio.TimeoutError):
            async with task.timeout(0.1):
                await slow_work()

    # Task priority management and scheduling
    @pytest.mark.asyncio
    async def test_priority_management(self):
        task = Asyn("priority_task")
        assert task.info.priority == TaskPriority.NORMAL
    
        task.set_priority(TaskPriority.HIGH)
        assert task.info.priority == TaskPriority.HIGH